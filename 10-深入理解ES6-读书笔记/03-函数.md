# 《深入理解ES6》读书笔记 #


## 第3章  函数 ##
----------
1. ES6的默认参数值
    ```JavaScript
    function makeRequest(url, timeout = 2000, callback = function() {

    }
    ```
- 其中，url是必需参数，其余两个为可选参数，当不传入参数或传入参数为undefined时，会使用默认值（注：null为合法值，可以传入）。

- 默认参数值对arguments对象的影响：
  - ES5中，非严格模式下：命名参数的变化会同步更新到arguments对象中；而严格模式下，arguments对象不再随之改变。 

  - ES6中与ES5的严格模式保持一致。；

  - 默认参数表达式
    - 可以通过函数执行来得到默认参数的值；
    
    - 由于默认参数是在函数调用时求值，所以可以使用先定义的参数作为后定义参数的默认值；但是只允许引用前面参数的值，先定义参数不能访问后定义的参数。

  - 默认参数的临时死区：与let和const一样，如果在初始化前访问变量，则会报错。

2. 处理无命名参数
- 不定参数：在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组，包含着自它传入的所有参数。通过数组名可以访问里面的参数。

    - 使用限制 ：
        - 每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾；
        - 不定参数不能用于对象字面量setter之中（因为setter的参数有且只能有一个）。

    - 对arguments对象的影响：无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。

3. 增强的Function构造函数
- 支持在创建函数时定义默认参数和不定参数。
    - 默认参数：在参数名后添加一个等号及一个默认值。

    - 不定参数：在最后一个参数前添加...即可。

4. 展开运算符
- ES5中，Math.max()方法不允许传入数组，需要使用apply()方法，如：
    ```javascript
    let values = [25,50,75,100];
    console.log(Math.max.apply(Math,values));
    ```
- ES6中，可以向Math.max()方法传入一个数组，再向数组前添加...符号，就不要调用apply()方法了，如：
    ```javascript
    let values = [25,50,75,100];
    console.log(Math.max.(...values); //100
    ```
    还可以传入其他参数，比如限定值：
    ```javascript
    let values = [-25,-50,-75,-100];
    console.log(Math.max.(...values,0);  //0
    ```

5. name属性
    - name属性值：
        - 声明函数的name属性值为声明时的函数名称；
        -  匿名函数表达式的name属性值为被赋值为该匿名函数的变量名。

    - name属性的特殊情况：
        - 函数表达式的名字比函数本身被赋值的变量的权重高；
        - getter函数的名称有get前缀，setter函数的名称有set前缀；
        - 通过bind()函数创建的函数，名称有bound前缀；
        - 通过Function构造函数创建的函数，名称是anonymous。

6. 明确函数的多重用途
- JavaScript函数有两个内部方法，[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]函数（具有此方法的函数被统称为构造函数），负责创建一个实例对象，然后再执行函数体，将this绑定到实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。

    - ES5中判断函数被调用的方法：
    一般使用instanceOf，如：`this instanceOf Person`。但不依赖new关键字也可以将this绑定到Person实例上，如apply()和call()方法，此时判断的就不准确了。
    
    - 元属性new.target:
    当调用[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建的对象实例，也就是函数体内this的构造函数；如果调用[[Call]]方法，则new.target的值为undefined。

7. 块级函数
- 在ES5中，当在代码块内部声明函数时程序会抛出错误；在ES6中，会将函数视为一个块级声明，从而可以在定义该函数的代码块内访问和调用，且块级函数会被提升至代码块顶部。

    - 使用场景：如果需要函数提升至代码块顶部，则选择块级函数；不需要则选择let表达式。

    - 非严格模式下的块级函数：不再提升至代码块顶部，而是提升至外围函数或全局作用域的顶部。

8. 箭头函数
- 与传统JavaScript函数的区别：
    - 没有this、super、arguments和news.target绑定：这些值由外围最近一层费箭头函数决定。

    - 不能通过new关键字调用：箭头函数没有[[Construct]]方法，所以不能被用作构造函数。

    - 没有原型：即不存在prototype属性。

    - 不可以改变this绑定：函数内部的this值不可被改变，在函数的生命周期内始终保持一致。

    - 不支持arguments对象：箭头函数没有arguments绑定，所以孩子难呢过通过命名参数和不定参数这两种方法访问函数的参数。

    - 不支持重复的命名参数。
