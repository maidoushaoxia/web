# 《深入理解ES6》读书笔记 #


## 第1章  块级作用域绑定 ##
----------
1. 变量提升机制
- 通过var关键字声明的变量，无论在何处声明，都会被当成在当前作用域顶部声明的变量，但初始化操作依然在原处执行。

2. 块级声明

- 块级作用域存在于：
  - 函数内部；
  - {}之间。

- let声明
  - 可以将变量的作用域限制在当前代码块中；
  - 乐意声明不会被提升，通常将let声明语句放在封闭代码块的顶部。

- 禁止重声明
  - 作用域已经存在的标识符，再使用let声明会报错；
  - 如果是当前作用域内嵌另一个作用域，便可在内嵌的作用域中用let声明同名变量。

- const声明
  - const声明的是常量，一旦声明不能修改；因此必须进行初始化；
  - const声明的常量与只在当前代码块内有效，一旦执行到块外即销毁，不会被提升至作用域顶部。
  - const声明的标识符也不能声明第二次；
  - 如果常量是对象，则对象中的值可以（不允许修改绑定，但允许修改绑定的值）。

- 临时死区
  - JavaScript引擎在发现变量声明时，要么将它们提升至作用域顶部，要么将声明放到临时死区中；
  - 在声明前访问let/const定义的变量就会报错（如typeOf）。

3. 循环中的块作用域绑定
- 可以将计数器变量限制在循环内部。

- 循环中的函数
  - 循环内部创建的函数全部保留了对相同变量的引用；
  - 为了解决这个办法，可以在循环中使用立即调用函数表达式（IIFE），为接受的每个变量都创建一个副本并存储为新变量。

- 循环中的let声明
  - let声明模仿立即调用函数表达式，每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化；
  - for-in循环也是，每次循环创建一个新的key绑定，每个函数都有一个变量key的副本。

- 循环中的const声明
  - 对于普通的for循环，初始化可以使用const声明，但后面更改这个值就会报错；
  - 在for-in和for-of中可以使用，因为每次迭代不会修改已有绑定，而是创建一个新的绑定。

4. 全局块作用域绑定
- 在全局作用域下使用let或const，会在全局作用域下创建一个新的绑定，但绑定不会添加为全局对象的属性，即不能覆盖全局变量，只能遮蔽它。

5. 块级绑定最佳实践的进化
- 默认使用const，确实需要改变变量的值时使用let。
