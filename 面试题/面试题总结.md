<!--
 * @Author: shaoyun
 * @Date: 2019-08-29 20:10:18
 * @LastEditors: shaoyun
 * @LastEditTime: 2019-09-05 20:09:42
 * @Description: 牛客网面试题总结
 -->
## 面试题总结

### CSS部分
1. margin塌陷
  - 兄弟元素之间竖直方向的margin不叠加，父子元素的子元素margin不生效；

  - 解决方案：给外部div元素创建一个BFC，overflow: hidden

2. 浮动
  - 缺点：浮动脱离文档流，边框高度不够高，会导致高度塌陷

  - 清除浮动： 
    - 在最后一个浮动元素后添加一个元素或使用:after伪元素，设置属性clear: both

    - 外部元素使用overflow: hidden

    - 使用BFC

3. BFC（块级格式化上下文）的触发条件
  - position: absolute/fixed

  - overflow: auto/hidden

  - display: inline-block

4. 居中的方法
  - 水平居中
    - 块级元素居中，设置margin: 0 auto

    - 行内元素居中，给父元素设置text-align: center

    - 多个块级元素居中，先设置display: inline-block，然后按行内元素居中

    - flex方法：父元素设置display: flex;justify-content: center; 

  - 垂直居中
    - 已知宽高，采用绝对定位：父元素相对定位，子元素绝对定位
      - 将元素的top和left都设为50%，再设置margin，实现垂直居中

      - 设置子元素margin为auto，距离top、right、bottom、left都为0

      - 设置行高等于父块级元素的高度：line-height: height
    
    - 未知宽高：
      - 要居中的元素是inline或inline-block元素，则将父元素设为display: table-cell; text-align: center

5. position
  - static： 无定位

  - relative： 相对与自己的位置定位，不会脱离文档流

  - absolute： 相对于static定位以外的第一个父元素，脱离文档流

  - fixed： 相对于浏览器窗口定位，脱离文档流

6. 盒模型
  - 标准盒模型：width只包含content

  - IE盒模型：width包含content + padding + border

  - box-sizing：
    - content-box：表示标准盒模型

    - border-box：表示IE盒模型

7. 弹性布局：将父元素设为display: felx; justify-content: space-between可以使子元素均匀放置。
</br>

8. CSS引入样式方法：
  - link标签引入外部样式：写在head标签中

  - @import引入外部样式

  - 内部样式：写在style中

  - 内联样式

9. 层叠上下文z-index
</br>

10. 动画
  - transform：translate、rotate、scale等。

  - transition：指定CSS属性变化所需要的时间。通常和hover事件配合使用，不能设定循环，且不能定义中间状态。transition属性分别是：需要变化的CSS属性、过渡时间、速度曲线、延迟时间。
    - transition: width 1s ease 0.2s

  - animation：指定动画效果及动画持续的时间。六个属性分别是：动画效果（key-frame名称）、过渡时间、速度曲线、延迟时间、播放次数、是否轮流反向播放。
    - animation: App-logo-spin（这是事先声明的关键帧） 1s ease 0 infinite alternate（轮流）

11. rem/em
  - rem：当前页面中元素的rem单位的样式值都是针对于HTML元素的font-size的值进行动态计算的。

  - em：表示相对于父元素的字体的倍数。

12. 三栏布局
  - 方法1：两侧绝对定位，中间宽度100%，设置padding

  - 方法2：左右都浮动，中间设置margin

13. 选择器优先级：
!important >内联样式 > id选择器 > 类、伪类及属性选择器 > 元素和伪元素选择器

### DOM部分
1. DOM事件流：从页面接收事件的顺序，一般是捕获阶段 => 实际目标接收到事件 => 冒泡阶段。
  - 事件冒泡：事件由具体的元素接收，然后逐级向上传播到不具体的节点。

  - 事件捕获：不太具体的节点先接收到事件，然后事件依次向下传播到事件的实际目标。

2. 事件委托：利用事件冒泡，管理某一类型的所有事件。一般是给父元素绑定事件，代理子元素的点击事件。
      ```javascript
      var div = document.getElementById('parent')

      div.onclick = function(event) {
        var event = event || window.event //获取当前事件的引用，兼容IE
        var target = event.target || event.srcElement // 获取事件的目标

        if (target.tagName.toLowerCase() === 'li') {
          // 事件处理
        }
      }

      // 点击父元素div，子元素的背景色变为黑色
      parent.addEventListener('click', function(){}, true)

      child.addEventListener('click', function() {
        child.style.backgroundColor ='black'
      })
      ```

3. Event对象（兼容IE）
  - 获取当前事件的引用：event || window.event

  - 获取事件的目标：event.target || event.srcElement

  - 阻止默认事件：event.preventDefault() || returnValue = false

  - 阻止冒泡：event.stopPropagation() || event.cancleBubble = true

### js部分
1. 变量提升：
  - js引擎先解析代码，获取所有被声明的变量，然后再运行，因此所有变量的声明语句都被提升到代码的头部。

  - 只有声明被提升，初始化不会提升，因此在头部打印会输出undefined;

  - 函数声明会被提升，但函数表达式不会。

  - 函数优先被提升，如果有同名变量，变量会被函数声明覆盖。

2. var、let与const区别
  - var有变量提升，而let和const不会

  - 临时死区：let和const无法变量提升，在变量声明前访问变量会报错，此时变量位于临时死区中，因此后面用let定义并初始化变量的语句不会执行。

3. 原型链
  - 每个对象实例都有_proto_属性，指向该对象的构造函数的原型（与构造函数无关）；

  - 构造函数的prototype指向它的原型；

  - 原型对象的constructor属性指向该原型的构造函数。

  - 对象在使用某个属性时，首先看自己有没有，如果没有就向上沿着原型链查找，直到找到为止。

  - **注意：**只有函数才有prototype属性，直接创建的对象（如`var obj = {}`)是没有的，但是一定有_proto_属性。

4. this指向
  - 默认情况下，this指向全局对象window；

  - 改变this指向：call、apply和bind

5. call、apply和bind实现
  - call： 第一个参数是指定的this，后面的参数是函数运行时的参数
    ```JavaScript
    function myCall (context) {
      context = context || window // 第一个参数可能为null
      context.fn = this // 这里的this是call前面的函数
      var arg = Array.prototype.slice.call(arguments, 1)
      // context.fn(...arg)
      let result = context.fn(...arg)
      delete context.fn // 执行完成后，为了不改变原有变量的属性，将添加的函数删除
      return result
    }
    
    // 将myCall挂载到Function的原型上
    Function.prototype.myCall = myCall
    ```

  - apply：只有两个参数，第一个参数是指定的this，第二个参数是包含函数执行所需参数的数组
    ```javascript
    function myApply(context, arr) {
      context = context || window
      context.fn = this
      var result
      if (arr) {
        result = context.fn(...arr)
      } else {
        result = context.fn()
      }
      delete context.fn
      return result
    }

    Function.prototype.myApply = myApply
    ```
  
  - bind：返回一个函数，需要时再调用，该函数运行时的this就是bind方法的第一个参数
    ```javascript
    // 普通版
    Function.prototype.myBind1 = function(context) {
      var _self = this
      var arg = Array.prototype.slice.call(arguments, 1) // 由于arguments是类数组对象，不拥有数组的slice方法，所以需要通过call来将slice的this指向arguments
      return function () {
        arg = arg.concat(Array.prototype.slice.call(arguments))
        return _self.apply(context, arg)
      }
    }

    // 作为构造函数时
    Function.prototype.myBind2 = function (context) {
      var _self = this
      var arg = Array.prototype.slice.call(arguments, 1)
      function fn () {
        arg = arg.concat(Array.prototype.slice.call(arguments))
        return _self.apply(this instanceof fn ? this : context, arg)
      }
      function Trans(){}
      Trans.prototype = _self.prototype
      fn.prototype = new Trans()
      return fn
    }
    ```

6. 箭头函数的this指向：指向外层包裹的对象。
</br>

7. async/awiat
  - async声明一个异步函数，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数；

  - await：只能在async函数内部使用，强制其它代码等待。

8. 类型存储地方：基本类型存储在栈中，复杂类型（还有闭包）存储在堆中。
</br>

9. 垃圾回收机制：
  - 标记清除

  - 引用计数

  - 解除引用（置为null）

10. getElementByClassName和querySelectorAll的区别
  - querySelectorAll方法接收的参数是一个CSS选择符，而getElementByClassName接收的是className

  - querySelectorAll方法返回的数组是静态的，对DOM操作返回的结果不会变化；而getElementByClassName方法返回的数组会更新旧的查询结果。

11. new做了什么：
  - 创建一个对象实例；

  - 将对象实例的原型（`_proto_`）指向构造函数的原型（prototype）

  - this指向新对象；

  - 若返回值为对象，则直接返回该对象；若无返回值或返回非对象值，则返回新创建的对象。

12. 闭包
  - 含义：内部函数可以访问其所在的外部函数的变量
    ```javascript
    function outer() {
      var a = 1
      function inner() {
        console.log(a)
      }
      return inner()
    }
    outer()
    ```

  - 闭包的作用：实现私有变量

13. 继承
  - 原型链继承：子函数共用一个原型，若有一个实例修改了引用类型的数据，其他实例都会受到影响。
    ```javascript
    function SuperType() {
      this.sayHello = 'hello'
      this.arr = [1,2,3]
    }

    function SubType() {}
    SubType.prototype = new SuperType()

    var instance1 = new SubType()
    var instance2 = new SubType()
    instance2.arr.push(4)
    ```

  - 类式继承：通过改变this指向，但是子类无法继承父类的原型
    ```javascript
    function SuperType(name, age) {
      this.name = name;
      this.age = age
    }

    function SubType() {
      SuperType.call(this, 'sy', 20) // 改变this指向
    }

    var instance = new SubType()
    ```

  - 组合继承
    ```javascript
    function SuperType(name) {
      this.name = name
      this.arr = [4,5,6]
    }

    function SubType(name, age) {
      SuperType.call(this, name) // 类式继承
      this.age = age
    }

    SubType.prototype = new SuperType() // 链式继承

    var instance1 = new SubType('sy', 20)
    var instance2 = new SubType('hh', 18)

    instance2.arr.push(7) // 不会改变其他实例
    ```

14. 防抖：当事件被触发时，设定一个周期延迟执行，若期间又被触发，则重新设定周期，直到周期结束再执行动作。（当一个动作连续触发，则只执行最后一次）
  - 非立即执行版：触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

  - 立即执行版：触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

15. 节流：预先设定一个执行周期，当调用事件的时刻大于等于执行周期则执行动作，然后进入下一个新周期。（连续触发事件但是在n秒中只执行一次函数）

16. 判断是数组
  - arr instanceof Array => true

  - Object.prototype.toString.call(arr) => '[objecct Array]'

  - Array.isArray(arr) => true

  - arr.constructor => Array()

17. 为什么要有箭头函数：因为this绑定经常会出错，在函数内很容易对this值失去控制。

### 网络部分
1. GET与POST区别
  - 传输方式不同：GET通过URL传递参数，POST的数据通过请求体传输；

  - 安全性不同：GET的数据暴露在URL，且会被浏览器主动缓存，相对不安全；

  - 浏览器刷新回退等，GET不会重新请求，但是POST会重新请求。

  - GET仅支持2KB大小。

2. HTTP报文组成
  - 请求报文：
    - 请求行
    - 请求头
    - 空行
    - 请求体

  - 响应报文：
    - 响应行
    - 响应头
    - 空行
    - 响应体

3. 状态码
  - 200：请求成功

  - 3xx：重定向
    - 301：永久重定向：浏览器收到响应后，自动将输入栏网址改变。

    - 302：临时重定向：浏览器收到响应后，输入栏显示的仍是旧网址，但显示的是新网址的内容。

    - 304：服务器判断请求的资源未被修改，则直接从缓存中获取。
  
  - 4xx：客户端错误
    - 403：请求资源的访问被拒绝，当后端要求get请求，而前端采用的是post请求时会出现。
    
    - 404：请求资源不存在，接口路径错误。

  - 5xx：服务器错误
    - 500：服务器端错误

4. 缓存的过程
  - 客户端向服务器发送请求；

  - 服务器返回资源，并通过响应头制定缓存策略；

  - 客户端根据响应头的策略决定是否缓存资源；

  - 客户端再次请求时会先去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存。

5. 强缓存与协商缓存
- 强缓存：
  - Expires：描述的是一个绝对时间，如果修改了本地时间可能会导致缓存失效。

  - Cache-Control：优先级高于Expires，描述的是一个相对时间。
    - Cache-Control:public可以被所有用户缓存；

    - Cache-Control:private只能被终端浏览器缓存；

    - Cache-Control:no-cache先缓存到本地，但每次发请求时都要向服务器验证；如果服务器允许才能使用本地缓存；

    - Cache-Control:no-store不会产生任何的缓存。

- 协商缓存：
  - 第一次请求时服务器返回的响应头中没有Expires和Cache-Control或强缓存过期又或者是属性为no-cache时，浏览器第二次请求就会与服务器进行协商。

  - 若缓存与服务端资源的最新版本一样，则返回304；若缓存为旧版本，则服务器将最新的资源返回给浏览器，返回200。

6. 三次握手
  - 客户端发送TCP的SYN=1的包，指明客户端打算连接服务器；

  - 服务器发回确认包应答SYN=1和ACK=1；

  - 客户端再次发送确认包，ACK=1。

7. 四次挥手
  - 若客户端向关闭连接，则发送一个FIN=1的包，表示已经没有数据可以发送了，但是仍可以接受数据；

  - 服务端确认客户端的FIN包，发送一个确认包ACK=1，表明自己收到了客户端关闭连接的请求，但还没有准备好关闭连接；

  - 服务端准备好关闭连接时，向客户端发送结束连接请求FIN=1；

  - 客户端接受到来自服务器端的关闭请求，发送一个确认包ACK=1.

8. Cookie、sessionStorge和localStorge
  - 共同点：都保存在浏览器端，且都是同源的。

  - 区别：
    - cookie会在浏览器和服务器之间来回传递；而sessionStorge和localStorge不会自动把数据发给服务器，仅在本地保存。

    - sessionStorge仅在浏览器窗口关闭前有效；而localStorge为持久数据；cookie在失效时间前一直有效。

9. 输入URL的过程
  - 用户在地址栏输入URL，首先检查缓存，如果有缓存就直接读取缓存；

  - 没有缓存就查询DNS服务器，解析IP地址；

  - 拿到IP地址后，发送HTTP请求；

  - 三次握手建立连接，四次挥手断开连接；

  - 下面是渲染流程，首先解析HTML，构建DOM树（如果读到外部引入的CSS或js文件，则需等js下载后立即执行，此时GUI渲染引擎会被挂起，但CSS文件不会阻断HTML解析）；

  - 然后构建CSSOM树（如果在js中操作了CSSOM，则需要等到响应CSS文件下载并构建CSSOM树后才继续执行js，且期间HTML解析一直挂起，所以CSS文件放在头部，js放在底部）；

  - 将DOM与CSSOM合并成一个渲染树（display不为none的可视节点）；

  - 根据render树布局，计算每个节点的几何信息，如果布局完成后修改DOM，则引发重排；

  - GPU将节点绘制到屏幕上，CSS背景色变化会引发重绘但不会重排。

10. 如何减少重排与重绘
  - 元素的样式尽量不要通过父元素去影响子元素，直接加在子元素上；

  - 减少DOM操作；

  - 使用visibility:hidden代替display:none，因为前者只会引发重绘，后者改变了布局会引发重排；

  - 将DOM操作都合并到一起，放在一个临时数组中，最后一次性更新DOM。
    ```javascript
    let fragment = document.createDocumentFragment()
    let item1 = document.createElement('li')
    let p1 = document.createTextNode('first')
    item1.appedChild(p1)
    fragment.appendChild(item1)
    let item2 = document.createElement('li')
    p2 = docment.createTextNode('second')
    item2.appendChild(p2)
    fragment.appendChild(item2)
    document.body.appendChild(fragment) // 仅引起一次回流
    ```

11. OSI七层模型：发送方从应用层到物理层，接收方从物理层到应用层。
  - 物理层
  - 数据链路层
  - 网络层
  - 传输层
  - 会话层
  - 表示层
  - 应用层

12. 同源策略：协议、域名和端口都相同
</br>

13. 跨域
  - jsonp：只支持get请求；

  - CORS：请求头添加Access-Control-Allow-Origin；
    - 简单请求：同时满足以下两个条件：
      - 请求方法是HEAD、GET、POST之一

      - HTTP头信息不超过以下几种字段
        - Accept
        - Accept-Language
        - Content-Language
        - Last-Event-ID
        - Content-Type：仅限于application/x-www-form-urlencoded、multipart/form-data、text/plain

      - 复杂请求：不满足以上条件。会先进行一次预请求，预请求通过后再进行正式请求。
        - 采用OPTIONS请求方法，表示这个请求是用来询问的；

        - 会在请求头加上：Access-Control-Request-Method

  - WebSocket：双向通信协议

  - postMessage方法：A向B发消息，B监听。
  
  - 代理：前端启了一个node服务，该服务接收到前台服务时向对应的服务发送请求，由于后台服务之间可以设置无同源政策，所以后台服务之间可以请求。

14. Ajax通信
  - 创建XmlHttpRequest对象；
    ```javascript
    var xmlHttp = new XmlHttpReauest() // readyState为0
    ```

  - 使用open方法设置请求的参数；
    ```javascript
    xmlHttp.open('get', url, true) // true为异步
    // readyState为1
    ```

  - 发送请求；
    ```javascript
    xmlHttp.send() // 若是post请求则要传参数
    // readyState为2，send过程中为3
    ```

  - 注册事件；
    ```javascript
    xmlHttp.onreadystatechange = function() {
      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
        // 请求成功后的操作
      }
    }
    ```

  - 获取返回的数据

15. 静态资源缓存
  - H5的Application Cache属性用于本地存储，构建离线缓存。
    - 增加manifest文件，浏览器会自动缓存带有manifest属性的HTML页面；

    - 在apache配置文件中添加 AddType text/cache-manifest .appcache

    - HTML中引用`<html lang="zh" manifest="main.manifest">`

  - 缓存更新后，第一次只能加载manifest文件，其他静态资源需要第二次加载才能看到最新效果。

### Vue部分
1. MVVM模式：
  - Model层：负责存储数据，也就是script里的代码，对数据进行操作

  - View层：负责显示数据，其实就是模板，随着数据改变，View层也随之改变；

  - ViewModel层：处理View层的具体业务逻辑。当ViewModel中数据变化，View层会更新；而当View中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。

2. 实现双向绑定：通过数据劫持以及发布者-订阅者模式实现。
  - 使用Object.defineProperty实现对数据改变的监听；

  - 使用观察者模式实现双向绑定，
    - 观察者Observer监听set属性变化，通知发布者Dep；

    - 发布者Dep收到通知，通知订阅者；

    - 订阅者Watcher收到属性变化的通知，执行回调函数，去更新视图。
    ```javascript
    // 数据监听器
    Object.defineReactive(data, key, val) {
      observe(val) // 递归遍历所有的属性
      var dep = new Dep()
      Object.defineProperty(data, key, {
        enumerable: true, // 枚举属性
        configurable: true, // 属性能被改变
        get: function() {
          if (Dep.target) { // 判断是否需要添加订阅者
            dep.addSub(Dep.target)
          }
          return val
        },
        set: function(newVal) {
          if (val === newVal) {
            return
          }
          val = newVal
          dep.notify() //发布者发出通知
        }
      })
    }

    function observe(data) {
      if (!data || typeof data !== 'object') {
        return
      }
      Object.keys(data).forEach(function(key) {
        defineReactive(data, key, data[key])
      })
    }
    ```
3. Vue生命周期
  - created：实例已经创建，属性也绑定了，data和methods都已经被初始化了，但真实dom还没生成，$el属性还不可用；

  - mounted：el挂载到实例上了，模板已经渲染完成。

4. Vue组件通信
  - 父子：props将数据向子传递，$emit和v-on向父传递信息；

  - 非父子：
    - eventBus：用一个空的Vue实例；
    
    - `$dispatch`和`$broadcast`

  - 祖孙：provide和inject；

  - vuex：全局数据管理
    - state属性，使用$store.state：只能读取；

    - mutations属性，使用$store.commit('method'),可以用来修改数据。

5. computed、methods和watch区别
  - computed：自动执行，具有缓存性，页面重新渲染值不变化时，计算属性直接返回之前的结果，不需要再次执行；

  - watch：自动执行，无缓存性，页面重新渲染时值不变化也会执行；

  - methods：主动调用的方法，无缓存性。

6. hash和history模式
  - hash路由：URL里有一个#，前端路由修改只能更改#后面的URL，而请求服务器时只有这个符号之前的内容会被包含在请求中。同时由于hash发生变化的url都会被浏览器记录下来，因此浏览器的前进后退都可以用。

  - history模式：前端的URL必须和实际发起请求的URL一致。有切换（前进forward、后退back及跳转go）和修改（pushState和replaceState）两大状态。一开始路由重定向了连接，但是刷新时，如果服务器中没有相应的响应或资源就报404，所以要在服务器端增加一个覆盖所有情况的候选资源，如果URL匹配不到任何静态资源，应该返回一个index.html页面。

7. 路由的生命周期（导航守卫）
  - 全局前置守卫：beforeEach(to,from, next)，导航触发时调用；

  - 全局解析守卫：beforeResolve，导航确认前，所有路由被解析后就被调用；

  - 全局后置钩子：afterEach(to, from)，不接受next函数，也不会改变导航本身；

  - 路由独享的守卫：beforeEnter(to,from, next)，在路由配置的时候就定义；

  - 组件内的守卫：
    - beforeRouteEnter：在渲染该组件的对应路由被confirm前调用，不能获取实例this，因为此时组件实例还没被创建；

    - beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用，可以访问this；

    - beforeRouteLeave：导航离开该组件对应路由时调用。可以访问this。

8. 路由跳转判断登录状态
  - 设置需要要校验的路由；
    ```javascript
    {
      path: '/componentA',
      name: 'componentA',
      component: componentA,
      meta:{
        requireLogin:true // 当前路由需要校验，不需要就不用写
      }
    }
    ```

  - 判断路由跳转是否需要登录权限（beforeEach钩子）
    ```javascript
     // to：即将进入的目标路由，from： 当前导航正要离开的路由， next：进行下一个钩子
    router.beforeEach((to, from, next) => {
      // 判断该路由是否需要登录权限
      if (to.matched.some(record => record.meta.requireLogin)) {
        // 判断当前用户的登录信息loginInfo是否存在
        if(sessionStorge.getItem('loginInfo')) {
          next() // 直接跳转
        } else {
          next({
            path: '/login' //跳转到登录页面
          })
        }
      } else {
        next() // 直接跳转
      }
    })
    ```

  - 登录组件内，登录成功的处理
    ```javascript
    this.$http({
      method: 'POST',
      url: this.userLoginUrl,
      data: prarm
    }).then((res) => {
      sessionStorge.setItem('loginInfo', JSON.stringify(res.data.result))
      this.$router.push('/HelloWorld') // 登陆成功后默认跳转的路由
    })
    ```

## Webpack部分
1. loader和plugins的区别：
  - loader：webpack将所有文件都视为模块，但只能解析js文件，loader是用来加载和解析非js文件的。loader本身是一个函数，接收源文件为参数，返回转换后的结果。如CSS-Loader、Style-Loader、babel-loader、eslint-loader等。loader运行在打包文件之前。

  - plugins：是一个具有apply属性的js对象，解决loader无法处理的问题。如html-webpack-plugin（简化html文件）等。webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后执行特定的逻辑，且插件可以调用webpack提供的API改变webpack的运行结果。plugins在整个编译周期都起作用。
    - HtmlWebpackPlugin：为html文件中引入的外部资源动态添加每次编译后的hash，防止引用了缓存的文件；**同时生成html入口文件，并对其进行压缩。**

2. Webpack的构建流程：
  - 初始化参数：从配置文件和shell语句中读取与合并参数，得到最终的参数；

  - 开始编译：初始化Compiler对象，加载所有配置文件。执行对象的run方法开始执行编译；

  - 确定入口：根据配置中的entry找到所有的入口文件；

  - 编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，再找出该模块依赖的模块，递归本步骤；

  - 完成模块编译：经过上一步，得到了每个模块编译后的最终内容以及他们之间的依赖关系；

  - 输出资源：根据入口和模块之间的依赖关系，组装成包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表；

  - 输出完成：确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

3. 了解Webpack相关
  * 什么是webpack
      * Webpack是一个模块打包器(bundler)。
      * 在Webpack看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理
      * 它将根据模块的依赖关系进行静态分析，生成对应的静态资源
  * 理解Loader
      * Webpack 本身只能加载JS模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载
      * Loader 本身也是运行在 node.js 环境中的 JavaScript 模块
      * 它本身是一个函数，接受源文件作为参数，返回转换的结果
      * loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。
  * 配置文件(默认)
      * webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象
  * 插件
    * 插件可以完成一些loader不能完成的功能。
    * 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。
    * CleanWebpackPlugin: 自动清除指定文件夹资源
    * HtmlWebpackPlugin: 自动生成HTML文件
    * UglifyJSPlugin: 压缩js文件

4. webpack配置代码
  ```javascript
    const htmlWebpackPlugin = require('html-webpack-plugin');
    const path = require('path')
    module.exports = {
      entry:{ //main是默认入口,也可以是多入口
          main:'./src/main.js'
      },
      //出口
      output:{
          filename:'./build.js', //指定js文件
          path: path.join(__dirname,'dist')          //最好是绝对路径
          //代表当前目录的上一级的dist
      },
      module:{
        //一样的功能rules:   webpack2.x之后新加的
        loaders:[       //require('./a.css||./a.js')
            {
              test:/\.css$/,
              loader:'style-loader!css-loader',
              //顺序是反过来的2!1
            },
            {
              test:/\.(jpg|svg|png|gif)$/,
              loader:'url-loader?limit=4096&name=[name].[ext]',
              //顺序是反过来的2!1 
              //[name].[ext]内置提供的，因为本身是先读这个文件
              // options:{
              //    limit:4096,
              //    name:'[name].[ext]'
              // }
            },
            {//处理ES6的js
              test:/\.js$/,
              loader:'babel-loader',
              //排除 node_modules下的所有
              exclude:/node_modules/,
              options:{
                  presets:['es2015'],//关键字
                  plugins:['transform-runtime'],//函数
              }
            }
        ]
      }
        plugins:[
          //插件的执行顺序是依次执行的
          new htmlWebpackPlugin({
              template:'./src/index.html',
              })
              //将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录
        ]
    }
  ```

## 其他部分
1. git的结构
  - 本地开发空间commit后提交到.git目录下的本地仓库，push后推到远程仓库，pull是从远程仓库到本地仓库。

2. fetch与pull的区别
  - fetch是从远端仓库下载到本地仓库；

  - pull是直接拉取，包含了merge操作。

3. rebase与merge的区别
  - reabse将本地仓库合并到开发空间；

  - merge是根据时间插入，会覆盖。
