# 06.27前端大会 #
---------------
## lambda表达式 ##
1. 本质：匿名方法

2. 其实就是箭头函数。。。

3. 题目：一行代码完成拼接给定字符二维数组为完整的字符串

  [
    ['t','u','p,],
    ['w','h','i'],
    ['t','s','u'],
    ['a','t','s'],
    ['h','a','p'],
    ['c','i','s']
    ['w','h','s']
  ]
  
  输出：['whatisup']

## 前端工程化实践 ##
1. WebPage模式：个人——静态页面

2. WebApp模式：多人——引入工程化思想

3. 定义：使用软件工程的技术和方法来进行前端项目的开发、维护和管理。

4. 包含六个部分：
  - 代码规范：ESLint等
    - 目录结构
    - 编码规范
    - 前后端接口
    - Commit描述规范

  - 分支管理：gitflow等

  - 模块管理
    - js/css模块化开发：可以达到代码复用。
    - 组件开发：
      - 页面上每个独立的可视/可交互区域视为一个组件；

      - 每个组件对应一个工程目录。组件所需的各种资源都在这个目录下就近维护。

      - assets与static目录的区别：
        - assets目录中的文件会被webpack处理解析为模块依赖，只支持相对路径形式（当前目录）；build的时候由Webpack解析为模块依赖。
        
        - static目录下的文件并不会被Webpack处理，它们会直接被复制到最终的打包目录（默认是dist/static）下。必须使用绝对路径（从盘符开始）引用这些文件。

  - 自动化测试

  - 构建：主干更新后，自动将代码编译成最终的目标格式，并准备好各种静态资源。

  - 部署：将构建好的代码部署到生产环境

5. 库/框架选型

## Electron开发 ##
1. 优点：基于node，跨平台开发；但是node是单线程多进程。

2. 是为了开发桌面应用程序

## Node.js与express搭建HTTP服务器 ##

## 浏览器缓存 ##
1. web缓存主要分为：浏览器缓存、代理缓存、网关缓存。

2. 浏览器缓存分为强缓存和协商缓存
  - 强缓存
    - Expires：设置了一个过期时间，这个时间之前不会来请求服务器，直接用缓存即可。
    缺点：请求的事件是服务器的事件，如果服务器与客户端时间不同步，会出现问题。

    - Cache-Control：给一个时间，这个时间过期了就会重新请求服务器。
    
  - 协商缓存：有一个last-modified属性，代表最新修改时间，并给一个缓存过期时间。当再次发起请求时，浏览器会比较服务器最新修改时间与之前传的修改时间，如果相等，则返回'304 notModified‘；如果修改过了，则返回last-modified。 
    - 缺点：用的是格林时间，只能精确到秒，1s内多次改动，浏览器无法获取最新的。如果服务器上资源被修改多次，但内容无变化，也会发起多次请求，因此造成资源浪费。

3. ETag:资源的唯一标识来判断，只有资源的内容改变时，ETag才会改变。If-None-Match是上一次的ETag。浏览器会在过期时间后重新请求时会比较当前的ETag与上一次的ETag，没改变就返回304。

4. 本地缓存
  - manifest（H5的应用缓存）

  - storge(Web存储机制)
    - sessionStorge
    - localStorge

5. 应用场景：IE10中

## Webgl ##

## JavaScript设计模式 ##
1. 创建型设计模式，分为5类：
  - 原型模式

  - 建筑者模式

  - 工厂模式

  - 单例模式：只允许实例化一次，一直改变这一个对象。

  - 抽象工厂模式

2. 结构性设计模式：
  - 代理模式proxy
  
  - 适配器模式Adapter

  - 装饰者模式Decorator：不改变原对象，添加属性方法来包装对象。

  - 组合模式：将对象组合成树形结构以表示“部分整体”的层次结构。

## React实践 ##
